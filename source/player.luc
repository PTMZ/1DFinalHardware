module player #(
    PROJAMT = 4 : PROJAMT > 0, // Width of the output
    STARTX = 3b1,
    STARTY = 3b1
  )
  
  (
    input clk,  // clock
    input rst,  // reset
    input up,
    input down,
    input left,
    input right,
    input projectileoutx[PROJAMT][3],
    input projectileouty[PROJAMT][3],
    input otherplayerx[3],
    input otherplayery[3],
    input obstacles[7][7][3],
    //output health[2], // 1-4 health
    output positionx[3], // 3bits of x 0-7 where 7 is
    output positiony[3], // 3bits of y 0-7 where 7 is for NULL hot encoding
    output gameend
  ) {
  
  .clk(clk) {
    edge_detector edUp(#RISE(1), #FALL(0)); // detect rising edges
    edge_detector edDown(#RISE(1), #FALL(0)); // detect rising edges
    edge_detector edLeft(#RISE(1), #FALL(0)); // detect rising edges
    edge_detector edRight(#RISE(1), #FALL(0)); // detect rising edges
    
    button_conditioner bcUp;     // button input conditioner
    button_conditioner bcDown;     // button input reset_conditioner
    button_conditioner bcLeft;     // button input reset_conditioner
    button_conditioner bcRight; // button input conditioner
    customCounter counter(.rst(rst));
    
    dff storex[3](#INIT(STARTX), .rst(rst));
    dff storey[3](#INIT(STARTY), .rst(rst));
    fsm state(.rst(rst)) = {WAIT, READY, COMPUTENEXT, CHECKOUTOFBOUNDS, CHECKOBSTACLES, CHECKOTHERPLAYER, UPDATE}; // create states for testing each of the fsm.
    dff newx[3];
    dff newy[3];
    
    // dff cooldown[22];
  }
  // instantiate i for counting
  var i;
  
  // instantiate the alu module
  alu16 alu;
  sig oldx[3];
  sig oldy[3];
  
  
  //for checks
  sig upordown;
  sig leftorright;
  sig uporright;
  sig downorleft;
  sig anybutton;
  
  sig outofbounds;
  
  sig currenplayerxy[6];
  sig otherplayerxy[6];
  
  sig obstacleobstruction;
  
  always {
    counter.amount = 10000000;
    counter.resetCd = 0;
    
    bcUp.in = up;
    bcDown.in = down;
    bcLeft.in = left;
    bcRight.in = right;
    
    edUp.in = bcUp.out;
    edDown.in = bcDown.out;
    edLeft.in = bcLeft.out;
    edRight.in = bcRight.out;
    
    // Create variable name oldx, oldy
    oldx = storex.q;
    oldy = storey.q;
    
    
    // Set to update the output to be the output calculated
    positionx = storex.q;
    positiony = storey.q;
    alu.alufn = 6b000000;
    alu.a = 0;
    alu.b = 0;
    
    // assign values
    upordown = edUp.out || edDown.out;  // for checking if to update x or y, 1 means update y
    leftorright = edLeft.out || edRight.out; // for checking if to update x or y, 1 means update x
    uporright = edUp.out || edRight.out; // for checking add or sub, 1 for add
    downorleft = edDown.out || edLeft.out; // for checking add or sub, 1 for sub
    anybutton = edUp.out || edDown.out || edLeft.out || edRight.out;
    
    // check outofbounds
    outofbounds = (&newx.q|| &newy.q); // 111 which is 7 when 3 bit 0-1 underflow or when out of bounds as display is 0-6
    
    // concatenate x and concatenate y
    currenplayerxy = c{newx.q, newy.q}; // concatenate to have easier comparing in 1 clock cycle
    otherplayerxy = c{otherplayerx, otherplayery}; // concatenate to have easier comparing in 1 clock cycle
    
    //check if new location has obstacles 1 if there is as each location is 3 bits if there is something then reduction would equal 1, all is 1 except 000 which is nothing.
    obstacleobstruction = |(obstacles[newx.q][newy.q]);
    
    case (state.q) {
      state.WAIT:
        storex.d = storex.q // not sure if needed but newx will change so wiring it to keep it same
        storey.d = storey.q // not sure if needed but newy will change so wiring it to keep it the sam
        newx.d = storex.q; // set initial x
        newy.d = storey.q; // set initial y 
        if (counter.ans == 1)
          state.d = state.READY; // only change the state when the counter has cooled down
      
      
      state.READY:
        if(anybutton){
          state.d = state.CHECKOUTOFBOUNDS; // change to next state if any button pressed
          if(upordown){
            alu.a = storey.q; // if up or down put in current y
            newy.d = alu.out; // set the output to update the y as well
          }
          if(leftorright){
            alu.a = storex.q; // if left or right put in current x
            newx.d = alu.out; // set the output to update the x as well
          }
          
          alu.b = 1; // constant 1 as we are always moving 1 space
          
          if(uporright){
            alu.alufn = 6b000000; // add to old value
          }
          if(downorleft){
            alu.alufn = 6b000001; // subtract from the value
          }
        }
      
      state.CHECKOUTOFBOUNDS:
        newx.d = newx.q; // not sure if needed but if it wireconnects from the previous, alu.out will change so rewiring to account for it
        newy.d = newy.q; // not sure if needed but if it wireconnects from the previous, alu.out will change so rewiring to account for it
        
        state.d = state.CHECKOBSTACLES;
        alu.alufn = 6b110010; //CMPEQ
        alu.a = obstacleobstruction;
        alu.b = 1; // always check against 1
        if(alu.out){
          newx.d = storex.q; // reset the value to update to back to original
          newy.d = storey.q; // reset the value to update to back to original
        }
      
      state.CHECKOBSTACLES:
        state.d = state.CHECKOTHERPLAYER;
        alu.alufn = 6b110010; //CMPEQ
        alu.a = obstacleobstruction;
        alu.b = 1; // always check against 1
        if (alu.out){ // means both same position
          newx.d = storex.q; // reset the value to update to back to original
          newy.d = storey.q; // reset the value to update to back to original
        }
      
      state.CHECKOTHERPLAYER:
        state.d = state.UPDATE;
        alu.alufn = 6b110010; //CMPEQ
        alu.a = currenplayerxy;
        alu.b = otherplayerxy;
        if (alu.out){ // means both same position
          newx.d = storex.q; // reset the value to update to back to original
          newy.d = storey.q; // reset the value to update to back to original
        }
      state.UPDATE:
        storex.d = newx.q; // update to the newx, if does not update is already taken into account
        storey.d = newy.q; // update to the newy, if does not update already taken into account.
        state.d = state.WAIT;
    }
    
    gameend = 0;
    for (i = 0; i < PROJAMT; i++) {
      if (projectileoutx[i] == storex.q && projectileouty[i] == storey.q)
        gameend = 1;
    }
    if(rst){
      storex.d = STARTX;
      storey.d = STARTY;
    }
  }
}