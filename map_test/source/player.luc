module player #(
    PROJAMT = 7 : PROJAMT > 0 // Width of the output
  )
  
  (
    input clk,  // clock
    input rst,  // reset
    input up,
    input down,
    input left,
    input right,
    input projectileoutx[7],
    input projectileouty[7],
    input otherplayerx[7],
    input otherplayery[7],
    input obstacles[7][7],
    //output health[2], // 1-4 health
    output positionx[7], // 7bits of x 1 hot encoding
    output positiony[7], // 7bits of y 1 hot encoding
    output gameend
  ) {
  
  .clk(clk) {
    edge_detector edUp(#RISE(1), #FALL(0)); // detect rising edges
    edge_detector edDown(#RISE(1), #FALL(0)); // detect rising edges
    edge_detector edLeft(#RISE(1), #FALL(0)); // detect rising edges
    edge_detector edRight(#RISE(1), #FALL(0)); // detect rising edges
    
    button_conditioner bcUp;     // button input conditioner
    button_conditioner bcDown;     // button input reset_conditioner
    button_conditioner bcLeft;     // button input reset_conditioner
    button_conditioner bcRight; // button input conditioner
    customCounter counter(.rst(rst));
    
    dff storex[7](#INIT(7b0000001), .rst(rst));
    dff storey[7](#INIT(7b0000001), .rst(rst));
    // dff cooldown[22];
  }
  // instantiate i for counting
  //sig i;
  
  
  sig oldx[7];
  sig oldy[7];
  sig newx[7];
  sig newy[7];
  
  // to convert to x and y dec
  digit_lut newpositionxdec;
  digit_lut newpositionydec;
  
  always {
    counter.amount = 50000000;
    counter.resetCd = 0;
    
    bcUp.in = up;
    bcDown.in = down;
    bcLeft.in = left;
    bcRight.in = right;
    
    edUp.in = bcUp.out;
    edDown.in = bcDown.out;
    edLeft.in = bcLeft.out;
    edRight.in = bcRight.out;
    
    oldx = storex.q;
    oldy = storey.q;
    newx = 0;
    newy = 0;
    newpositionxdec.value = newx;
    newpositionydec.value = newy;
    
    
    if (counter.ans == 1){
      // Movement to update position
      if(edUp.out){
        newy = storey.q << 1;
        // Check boundary
        if ((newy) == 7b0000000)
          storey.d = oldy;
        // Check if other player is in same square
        else if (c{oldx, newy} == c{otherplayerx, otherplayery})
          storey.d = oldy;
        // Check the obstacle list at the location of the new player position if it is 1 then don't move
        else if (obstacles[newpositionxdec.dec][newpositionydec.dec] == 1)
          storey.d = oldy;
        // Else Move
        else
          storey.d = newy;
        
        counter.resetCd = 1;
      }
      
      if(edDown.out){
        newy = storey.q >> 1;
        // Check boundary
        if ((newy) == 7b0000000)
          storey.d = oldy;
        // Check if other player is in same square
        else if (c{oldx, newy} == c{otherplayerx, otherplayery})
          storey.d = oldy;
        // Check the obstacle list at the location of the new player position if it is 1 then don't move
        else if (obstacles[newpositionxdec.dec][newpositionydec.dec] == 1)
          storey.d = oldy;
        // Else Move
        else
          storey.d = newy;
        
        counter.resetCd = 1;
      }
      
      if(edLeft.out){
        newx = storex.q << 1;
        // Check boundary
        if ((newx) == 7b0000000)
          storex.d = oldx;
        // Check if other player is in same square
        else if (c{newx, oldy} == c{otherplayerx, otherplayery})
          storex.d = oldx;
        // Check the obstacle list at the location of the new player position if it is 1 then don't move
        else if (obstacles[newpositionxdec.dec][newpositionydec.dec] == 1)
          storey.d = oldx;
        // Else Move
        else
          storex.d = newx;
        
        counter.resetCd = 1;
      }
      
      if(edRight.out){
        newx = storex.q >> 1;
        // Check boundary
        if ((newx) == 7b0000000)
          storex.d = oldx;
        // Check if other player is in same square
        else if (c{newx, storey.q} == c{otherplayerx, otherplayery})
          storex.d = oldx;
        // Check the obstacle list at the location of the new player position if it is 1 then don't move
        else if (obstacles[newpositionxdec.dec][newpositionydec.dec] == 1)
          storey.d = oldx;
        // Else Move
        else
          storex.d = newx;
        
        counter.resetCd = 1;
      }
    }
    // Set to update the output to be the output calculated
    positionx = storex.q;
    positiony = storey.q;
    
    
    // checkcooldown
    // cooldown.d = cooldown.q-1 >= 0 ? cooldown.q-1 : 0;
    // to check if hit for each projectile check the x and y of player coincide with projectile.
    //    i = 0;
    //    for (i = 0; i <= PROJAMT; i++) {
    // check each position at each index. Concatenation of both posx and posy assuming 1 health
    //      if(projectileout[i] == c{storex.q, storey.q})
    //        gameend = 1;
    //      else
    ///        gameend = 0;
    
    if (c{projectileoutx, projectileouty} == c{storex.q, storey.q})
      gameend = 1;
    else
      gameend = 0;
    
  }
}